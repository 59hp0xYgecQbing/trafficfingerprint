1. איך KMEANS++ עובד
2. איך חיפשו התאמה
3. עבדתם עם LZ? בניתם עץ? איך בניתם את הFINGERPRINT
4. איך מצאתם התאמה מול רצף "רועש"?
5. מה הם עשו עם מצבים שבהם לא מוצאים רצף בעץ
6. איך קבעתם את הTHRESHOLD

Kmeans cluster נותן כמות ערכים בcluster.
הקלט: K ערכים, הkmeans מסווג את כלל הערכים לאותו cluster שמתאים לו.
[1,2,3,4,5,6,7,8,9,10] - עם 5 קלאסטרים, אולי נקבל קלאסטר ריק. ה Kmeans++ זורק קלאסטרים כאלה.

לשלוח לו כמות קלאסטרים שרוצים, ו observation vector. אולי לממש בעצמנו?


2. השוואות - טיפוס בעץ הוא עשה list של טבלאות האש ושם היו כל הבנים. המפתח שלו היה הערך קוואנטיזציה.
כל מי שהשווה אצלו- הוא לא ידע להסביר להם ושם אסף נפל.
הטעות שלו - הוא חושב שאפשר לקחת PCAP, לעשות עץ לPCAP אחד, לPCAP שני ולעשות התאמה. זה לוקח שנים וזה לא ישים.
תעשו את זה כמה שיותר לקוני. PCAP נקי מול PCAP נקי. תשוו ביניהם.

"תקחו את זה כמו שזה". תעשו עץ כנגד עץ.
אצלי, העצים היו מבחינת גודל - כמות הערכים - השוואה תמיד של אותה הכמות. אם יש לכידה של 3000 ולכידה של 2000, נבנה עץ של מקסימום עד 2000.
תמיד השוויתי באותו הגודל.

הפרוייקט שלי היה די מוצלח כי הצלחתי כביכול לראות שיש התאמות או אין התאמות. PCAP של פייסבוק, ואז לקחתי PCAP לא ידוע, שמתי בבדיקה והראה לי "יש התאמה לפייסבוק ב80% בערך".
לקחתי PCAPים, PCAPים אקראיים - ויכלתי לגלות אם הם שייכים וכד'.

היה לי הכי קשה מול PCAP מאותו פרוטוקול - Walla מול FB היה באחוזים בודדים שונה. Skype מול HTTP זה היה ממש בשנייה 

נצטרך לשאוף ל PCAP שהוא unknown, ויש DB - לקחת את ה PCAP ולהשוות מול ה DB ולבדוק אם יש התאמה.